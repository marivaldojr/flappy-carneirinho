<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Carneirinho</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            font-family: 'Press Start 2P', cursive;
            color: white;
            text-align: center;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            height: 100%;
            max-height: 600px;
            background: #87CEEB; /* Cor do céu */
            overflow: hidden;
            border: 5px solid #333;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Permite cliques através do container */
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        #game-over-message {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            display: none; /* Escondido por padrão */
            flex-direction: column;
            align-items: center;
        }
        #game-over-message h1 {
            margin: 0 0 10px 0;
            font-size: 1.5rem;
        }
        #game-over-message p {
            margin: 0;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container">
        <div id="score">0</div>
        <div id="game-over-message">
            <h1>Fim de Jogo</h1>
            <p>Pontuação Final: <span id="final-score">0</span></p>
            <p style="margin-top: 15px;">Clique para jogar novamente</p>
        </div>
    </div>
</div>

<script>
    // Seleciona os elementos do DOM
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const scoreDisplay = document.getElementById('score');
    const gameOverMessage = document.getElementById('game-over-message');
    const finalScoreDisplay = document.getElementById('final-score');

    let bird, obstacles, score, gameState;

    // --- Carregamento das Imagens ---
    const characterImage = new Image();
    const characterHitImage = new Image();
    const sheepImage = new Image();
    const introImage = new Image(); // Nova imagem de fundo da introdução
    let imagesLoadedCount = 0;
    const totalImages = 4; // Agora são 4 imagens para carregar

    function onImageLoad() {
        imagesLoadedCount++;
        if (imagesLoadedCount === totalImages) {
            setup();
            gameLoop();
        }
    }

    function onImageError(e) {
        console.error("Erro ao carregar a imagem:", e.target.src);
        // Tenta iniciar mesmo com erro, o jogo terá fallbacks
        imagesLoadedCount++;
         if (imagesLoadedCount === totalImages) {
            setup();
            gameLoop();
        }
    }
    
    characterImage.crossOrigin = "Anonymous";
    characterHitImage.crossOrigin = "Anonymous";
    sheepImage.crossOrigin = "Anonymous";
    introImage.crossOrigin = "Anonymous";
    
    characterImage.onload = onImageLoad;
    characterHitImage.onload = onImageLoad;
    sheepImage.onload = onImageLoad;
    introImage.onload = onImageLoad;
    
    characterImage.onerror = onImageError;
    characterHitImage.onerror = onImageError;
    sheepImage.onerror = onImageError;
    introImage.onerror = onImageError;

    characterImage.src = 'https://i.imgur.com/OV1NOB8.png';
    characterHitImage.src = 'https://i.imgur.com/kjRAXfJ.png';
    sheepImage.src = 'https://i.imgur.com/YW8MXms.png';
    introImage.src = 'https://i.imgur.com/BCvgnFY.png';


    // Função para ajustar o tamanho do canvas
    function resizeCanvas() {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Configurações do jogo
    const birdProps = {
        x: 50,
        y: 150,
        radius: 20,
        gravity: 0.4,
        lift: -8,
        velocity: 0
    };

    const obstacleProps = {
        width: 50,
        height: 50,
        gap: 220,
        speed: 3,
        frequency: 90
    };

    let frameCount = 0;

    // Função para inicializar ou reiniciar o jogo
    function setup() {
        bird = { ...birdProps, y: canvas.height / 2 };
        obstacles = [];
        score = 0;
        frameCount = 0;
        gameState = 'intro'; // O jogo começa no estado de introdução
        scoreDisplay.style.display = 'none';
        gameOverMessage.style.display = 'none';
        draw();
    }

    // Loop principal do jogo
    function gameLoop() {
        if (gameState === 'playing') {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Atualiza o estado do jogo
    function update() {
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;

        frameCount++;
        if (frameCount % obstacleProps.frequency === 0) {
            const gapY = Math.random() * (canvas.height - obstacleProps.gap - 200) + 100;
            obstacles.push({ x: canvas.width, y: gapY, passed: false });
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].x -= obstacleProps.speed;
            if (obstacles[i].x + obstacleProps.width < 0) {
                obstacles.splice(i, 1);
            }
            if (checkCollision(bird, obstacles[i])) {
                endGame();
            }
            if (!obstacles[i].passed && obstacles[i].x < bird.x) {
                obstacles[i].passed = true;
                score++;
                scoreDisplay.textContent = score;
            }
        }

        if (bird.y + bird.radius > canvas.height || bird.y - bird.radius < 0) {
            endGame();
        }
    }
    
    // Desenha tudo no canvas
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (gameState === 'intro') {
            // Desenha a tela de introdução
            ctx.drawImage(introImage, 0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            
            // Título do jogo em duas linhas
            const titleFontSize = canvas.width / 12; // Tamanho da fonte responsivo
            ctx.font = `${titleFontSize}px 'Press Start 2P'`;
            ctx.fillText('Flappy', canvas.width / 2, canvas.height / 3 - titleFontSize * 0.6);
            ctx.fillText('Carneirinho', canvas.width / 2, canvas.height / 3 + titleFontSize * 0.6);
            
            // Instrução para jogar
            const instructionFontSize = canvas.width / 25; // Tamanho da fonte responsivo
            ctx.font = `${instructionFontSize}px 'Press Start 2P'`;
            ctx.fillText('Clique para Jogar', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        // Desenha o fundo normal durante o jogo
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let currentImage = characterImage;
        if (gameState === 'over') {
            currentImage = characterHitImage;
        }

        // Desenha o personagem
        if (imagesLoadedCount >= 2) {
            const size = bird.radius * 2.5;
            const x = bird.x - size / 2;
            const y = bird.y - size / 2;
            ctx.drawImage(currentImage, x, y, size, size);
        } else {
            ctx.beginPath();
            ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
        }

        // Desenha os obstáculos (colunas de carneiros)
        if (imagesLoadedCount >= 3) {
            for (const obs of obstacles) {
                for (let y = obs.y - obstacleProps.height; y > -obstacleProps.height; y -= obstacleProps.height) {
                    ctx.drawImage(sheepImage, obs.x, y, obstacleProps.width, obstacleProps.height);
                }
                for (let y = obs.y + obstacleProps.gap; y < canvas.height; y += obstacleProps.height) {
                    ctx.drawImage(sheepImage, obs.x, y, obstacleProps.width, obstacleProps.height);
                }
            }
        }
    }

    function flap() {
        if (gameState === 'playing') {
            bird.velocity = birdProps.lift;
        } else if (gameState === 'intro') {
            startGame();
        } else if (gameState === 'over') {
            setTimeout(setup, 200);
        }
    }

    function startGame() {
        if (imagesLoadedCount < totalImages) return;
        gameState = 'playing';
        scoreDisplay.style.display = 'block';
        bird.velocity = birdProps.lift;
    }
    
    function endGame() {
        gameState = 'over';
        finalScoreDisplay.textContent = score;
        gameOverMessage.style.display = 'flex';
        scoreDisplay.style.display = 'none';
    }

    function checkCollision(bird, obs) {
        const birdLeft = bird.x - bird.radius;
        const birdRight = bird.x + bird.radius;
        const birdTop = bird.y - bird.radius;
        const birdBottom = bird.y + bird.radius;
        const obsRight = obs.x + obstacleProps.width;
        
        if (birdRight > obs.x && birdLeft < obsRight) {
            const topPipeBottom = obs.y;
            const bottomPipeTop = obs.y + obstacleProps.gap;
            if (birdTop < topPipeBottom || birdBottom > bottomPipeTop) {
                return true;
            }
        }
        return false;
    }

    // Eventos de input
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); flap(); }
    });
    document.addEventListener('mousedown', flap);
    document.addEventListener('touchstart', (e) => { e.preventDefault(); flap(); });

</script>

</body>
</html>
